<h1
id="eve-single-molecule-localization-fitting-software-for-event-based-sensors">Eve:
Single-molecule localization fitting software for event-based
sensors</h1>
<h2 id="overview">Overview</h2>
<p>Eve is a software package that provides a plethora of options to
localize emitters from single molecule localization microscopy (SMLM)
experiments performed on a MetaVision event-based sensor (eveSMLM).</p>
<h2 id="for-users">For users</h2>
<p>Eve has multiple analysis parts:</p>
<ol type="1">
<li>Processing: This is the core of Eve, and allows for a multitude of
options of single-molecule finding and fitting. After processing has
finished, Eve creates a .csv file containing the localization data. More
details on processing below.</li>
<li>Post-processing: This contains general functions that can be run on
the obtained list of localizations, such as filtering, drift correction,
localization accuracy prediction, etc.</li>
<li>Visualisation: Contains options to visualise the obtained
localizations.</li>
</ol>
<h3 id="general-usage-instructions">General usage instructions:</h3>
<ol type="1">
<li>Ensure that the global settings are properly set. In the section
‘global settings’, press ‘advanced settings’ and ensure that these are
correct. The MetaVision SDK path is the folder that contains all
metavision python .pyd files and metavision_core, _hal, _sdk
folders.</li>
<li>In the ‘Processing’ tab, choose your dataset location. This could be
a MetaVision .raw file, or a .npy file containing x, y, polarity, time
columns. If a .npy file is not found, it will be created by converting
the .raw file. Alternatively, a folder can be chosen, and the analysis
will be run on all .raw and/or .npy files in this folder.</li>
<li>Under ‘Candidate finding’, choose candidate finding options and set
required (bold) and optional (italics) parameters. Hover over the title
for brief information on the settings and method. The output of the
candidate finding routine is a collection of sets of events, where each
set of events make up a single localization.</li>
<li>Under ‘Candidate fitting’, choose candidate fitting options and set
required (bold) and optional (italics) parameters. Hover over the title
for brief information on the settings and method. The output of the
candidate fitting routine is a list of localizations.</li>
<li>Press ‘Run’. Observe running documentary of the fitting process in
the ‘Run info’ tab or Python command line. After fitting is complete, a
.csv containing the localizations will be created, and the ‘Localization
List’ tab will be filled with the found localizations.</li>
<li>Observe the found localizations in the ‘Localization List’ tab,
visualise these via the ‘Visualisation tab’ and/or correct/analyse these
via the ‘Post-processing’ tab.</li>
</ol>
<h2 id="for-developers">For developers</h2>
<p>Eve is created from the ground up to be flexible and allowing for
easy implementation of new candidate finding and fitting routines. To
add new routines, a new .py file can be created in the CandidateFinding
or CandidateFitting folder, respectively, and these will be
automatically found and run by Eve. Here are instructions on how to
create these files. For exemplary finding and fitting routines, see
CandidateFinding/DummyCandidateFinding.py and
CandidateFitting/SimpleOperants.py.</p>
<h3 id="function-structure">Function structure</h3>
<p>Eve will recognise any and all functions present in the
CandidateFinding/CandidateFitting folders, and thus can be expanded at
will. Every .py file in these folders is <strong>required</strong> to
have the following function as the first function:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Required function __function_metadata__</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Should have an entry for every function in this file</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> __function_metadata__():</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;FunctionOne&quot;</span>: {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;required_kwargs&quot;</span>: [</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;req_kwarg_1&quot;</span>, <span class="st">&quot;description&quot;</span>: <span class="st">&quot;The first required keyword-argument&quot;</span>,<span class="st">&quot;default&quot;</span>:<span class="dv">10</span>},</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;req_kwarg_2&quot;</span>, <span class="st">&quot;description&quot;</span>: <span class="st">&quot;The second required keyword-argument&quot;</span>,<span class="st">&quot;default&quot;</span>:<span class="st">&quot;A nice string&quot;</span>},</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;optional_kwargs&quot;</span>: [</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;opt_kwarg&quot;</span>, <span class="st">&quot;description&quot;</span>: <span class="st">&quot;An optional keyword-argument&quot;</span>},</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;help_string&quot;</span>: <span class="st">&quot;The help string of the first function.&quot;</span>,</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;display_name&quot;</span>: <span class="st">&quot;Function One Display Name&quot;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        },</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;FunctionTwo&quot;</span>: {</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;required_kwargs&quot;</span>: [</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;optional_kwargs&quot;</span>: [</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;help_string&quot;</span>: <span class="st">&quot;The help string of the second function. This function has no required or optional arguments&quot;</span>,</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;display_name&quot;</span>: <span class="st">&quot;Function Two Display Name&quot;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        },</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>This function metadata provides information and pointers towards all
functions found in this .py file. By implementing this .py file, Eve
will be expanded by two functions: “Function One Display Name” which
calls <em>FunctionOne</em>, and “Function Two Display Name”, which calls
<em>FunctionTwo</em>. <em>FunctionOne</em> will be called with two
required keyword-arguments and one optional keyword-arguments. This
means that <em>FunctionOne</em> will be called with argument
<em>kwarg</em>, containing <em>kwarg[‘req_kwarg_1’]</em> and
<em>kwarg[‘req_kwarg_2’]</em>. Optionally, <em>kwarg[‘opt_kwarg’]</em>
will also be present. The <em>default</em> values will be the pre-filled
values in the Eve software, but Eve does not handle any
type-checking.</p>
<p>In ‘def FunctionOne()’ (and all other defined functions), it is
recommended to run the following line:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[provided_optional_args, missing_optional_args] <span class="op">=</span> utilsHelper.argumentChecking(__function_metadata__(),inspect.currentframe().f_code.co_name,kwargs) <span class="co">#type:ignore</span></span></code></pre></div>
<p>This checks that all required arguments are present, and provides the
provided and missing optional arguments.</p>
<h3 id="candidate-finding">Candidate finding</h3>
<p>Candidate finding functions should be structured as follows:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> FunctionOne(npy_array,settings,<span class="op">**</span>kwargs):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Perform function here</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Create candidates and metadata</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> candidates, metadata</span></code></pre></div>
<p><em>FunctionOne</em> should be a function name defined as such in the
file’s <strong>function_metadata</strong>. It is allowed to call other
functions that are not necessarily defined in
<strong>function_metadata</strong>.</p>
<h4 id="candidate-finding-input">Candidate finding input</h4>
<p>As seen above, the candidate finding functions are ran with 3
parameters: npy_array, settings, and kwargs (key-word-arguments).</p>
<ul>
<li>npy_array: An N-sized array, where N is the number of events in the
dataset. Every event (i.e. npy_array[0]) is a (4-by-1) array containing
x, y, p, t (x-pixel, y-pixel, polarisation, time in microsecond), and
can be called by e.g. npy_array[0][‘x’].</li>
<li>settings: Contains the global settings. Most importantly,
settings[‘PixelSize_nm’] contains the pixel size in nm.</li>
<li>kwargs: All keyword arguments as defined above. Please note that
<strong>all entries are strings</strong>. I.e. kwarg[‘req_kwarg_1’] will
output <strong>“10”</strong>. If a number is required instead, use
‘float(kwarg[’req_kwarg_1’])’.</li>
</ul>
<h4 id="candidate-finding-output">Candidate finding output</h4>
<p>Candidate fitting should output a <em>candidates</em> dictionary and
a <em>metadata</em> string.</p>
<ul>
<li>The <em>candidates</em> dictionary should have an entry for each
cluster, and should minimally contain the following entries:
<strong>‘events’</strong>, which contains all events ([x, y, polarity,
time]-headered) belonging to this cluster; <strong>‘N_events’</strong>,
an integer value of the number of events belonging to this cluster; and
<strong>‘cluster_size’</strong>, a (3,1)-sized array which contains the
x-dimension, y-dimension, and time-dimension, respectively (can be used
to filter on).</li>
<li>The <em>metadata</em> string should be a single- or multi-line
string, and can store information about the ran candidate finding
routine.</li>
</ul>
<h4
id="pseudo-code-to-explain-the-structure-of-candidates-finding-output">Pseudo-code
to explain the structure of candidates finding output</h4>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>candidates <span class="op">=</span> {}</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> cluster <span class="kw">in</span> all_clusters:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    clusterEvents <span class="op">=</span> all_cluster_events(cluster_id<span class="op">==</span>cluster)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    candidates[cluster] <span class="op">=</span> {}</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    candidates[cluster][<span class="st">&#39;events&#39;</span>] <span class="op">=</span> clusterEvents</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    candidates[cluster][<span class="st">&#39;N_events&#39;</span>] <span class="op">=</span> <span class="bu">len</span>(clusterEvents)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    candidates[cluster][<span class="st">&#39;cluster_size&#39;</span>] <span class="op">=</span>...</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    [np.<span class="bu">max</span>(clusterEvents[<span class="st">&#39;y&#39;</span>])<span class="op">-</span>np.<span class="bu">min</span>(clusterEvents[<span class="st">&#39;y&#39;</span>]),...</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    np.<span class="bu">max</span>(clusterEvents[<span class="st">&#39;x&#39;</span>])<span class="op">-</span>np.<span class="bu">min</span>(clusterEvents[<span class="st">&#39;x&#39;</span>]),...</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    np.<span class="bu">max</span>(clusterEvents[<span class="st">&#39;t&#39;</span>])<span class="op">-</span>np.<span class="bu">min</span>(clusterEvents[<span class="st">&#39;t&#39;</span>])]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>metadata <span class="op">=</span> <span class="st">&#39;The file ran as expected!&#39;</span></span></code></pre></div>
<h3 id="candidate-fitting">Candidate fitting</h3>
<p>Candidate finding functions should be structured as follows:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> FunctionOne_Fitting(candidate_dic,settings,<span class="op">**</span>kwargs):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Perform function here</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Create localizations and metadata</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> localizations, metadata</span></code></pre></div>
<p><em>FunctionOne_Fitting</em> should be a function name defined as
such in the file’s <strong>function_metadata</strong>. It is allowed to
call other functions that are not necessarily defined in
<strong>function_metadata</strong>.</p>
<h4 id="candidate-fitting-input">Candidate fitting input</h4>
<p>As seen above, the candidate fitting functions are ran with 3
parameters: candidate_dic, settings, and kwargs
(key-word-arguments).</p>
<ul>
<li>candidate_dic: The output of a candidate finding routine: a
dictionary with an entry for each found cluster. See the paragraph above
for information on this.</li>
<li>settings: Contains the global settings. Most importantly,
settings[‘PixelSize_nm’] contains the pixel size in nm.</li>
<li>kwargs: All keyword arguments as defined above. Please note that
<strong>all entries are strings</strong>. I.e. kwarg[‘req_kwarg_1’] will
output <strong>“10”</strong>. If a number is required instead, use
‘float(kwarg[’req_kwarg_1’])’.</li>
</ul>
<h4 id="candidate-finding-output-1">Candidate finding output</h4>
<p>Candidate fitting should output a <em>localizations</em> pandas
dataframe and a <em>metadata</em> string.</p>
<ul>
<li>The <em>localizations</em> pandas dataframe should have a separate
entry for each localization, and each localization should at minimum
contain the following inputs: <strong>‘x’</strong>: x-position in nm
(float); <strong>‘y’</strong>: y-position in nm (float);
<strong>‘p’</strong>: polarity of the localization (0 for negative, 1
for positive); <strong>‘t’</strong>: time in ms (milliseconds)</li>
<li>The <em>metadata</em> string should be a single- or multi-line
string, and can store information about the ran candidate finding
routine.</li>
</ul>
<h4
id="pseudo-code-to-explain-the-structure-of-candidate-fitting-output">Pseudo-code
to explain the structure of candidate fitting output</h4>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>localizations <span class="op">=</span> {}</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> np.unique(<span class="bu">list</span>(candidate_dic)):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    localizations[i]<span class="op">=</span>{}</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    localizations[i][<span class="st">&#39;x&#39;</span>] <span class="op">=</span> np.mean(candidate_dic[i][<span class="st">&#39;events&#39;</span>][<span class="st">&#39;x&#39;</span>])<span class="op">*</span><span class="bu">float</span>(settings[<span class="st">&#39;PixelSize_nm&#39;</span>][<span class="st">&#39;value&#39;</span>]) <span class="co">#X position in nm</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    localizations[i][<span class="st">&#39;y&#39;</span>] <span class="op">=</span> np.mean(candidate_dic[i][<span class="st">&#39;events&#39;</span>][<span class="st">&#39;y&#39;</span>])<span class="op">*</span><span class="bu">float</span>(settings[<span class="st">&#39;PixelSize_nm&#39;</span>][<span class="st">&#39;value&#39;</span>]) <span class="co">#Y position in nm</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    localizations[i][<span class="st">&#39;p&#39;</span>] <span class="op">=</span> <span class="dv">1</span> <span class="co">#Polarisation: 0 or 1</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    localizations[i][<span class="st">&#39;t&#39;</span>] <span class="op">=</span> np.mean(candidate_dic[i][<span class="st">&#39;events&#39;</span>][<span class="st">&#39;t&#39;</span>])<span class="op">/</span><span class="dv">1000</span> <span class="co">#time in ms</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Make a pd dataframe out of it - needs to be transposed</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>localizations <span class="op">=</span> pd.DataFrame(localizations).T</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>metadata <span class="op">=</span> <span class="st">&#39;The file ran as expected!&#39;</span></span></code></pre></div>
